#javascript面向对象

1.function

  由事件驱动的或者被调用时执行的代码块，他是可以重复使用的。

  1.1函数声明：

    function fn(n1,n2){
      return n1+n2;
    }

  1.2函数表达式，又叫函数字面量

    var sum2=function(n1,n2){
        return n1+n2;
    };

    两者的区别：解析器会先读取函数声明，并使其在执行任何代码之前可以访问；而函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行。

    自执行函数严格来说也叫函数表达式，它主要用于创建一个新的作用域，在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函数方式存在，且立即自动执行。

      (function(n1,n2){
        console.log (n1+n2)
      })(1,3);//4

  1.3.函数构造法，参数必须加引号

    var sum3=new Function('n1','n2','return n1+n2');
    console.log(sum3(2,3));//5

    从技术角度讲，这是一个函数表达式。一般不推荐用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。

    var name='haoxl';

    function fun(){
      var name='lili';
      return new Function('return name');//不能获取局部变量
    }

    console.log(fun()());//haoxl

     Function()构造函数每次执行时都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或频繁执行的函数中调用Function()构造函数效率是非常低的。而函数字面量却不是每次遇到都会重新编译的，用Function()构造函数创建一个函数时并不遵循典型的作用域，它一直把它当作是顶级函数来执行。

2.Object

  2.1对象的创建

    //new Object，实例化一个Object 
    var a=new Object(); 
    a.x=1,a.y=2; 

    //对象直接量 
    var b={x:1,y:2}; 

    //定义类型 
    function Point(x,y){ //类似于C#中的类 
    this.x=x; 
    this.y=y; 
    } 
    var p=new Point(1,2); //实例化类

  2.3对象属性的封装(公有和私有)

  2.3属性和方法的类型

    javascript里，对象的属性和方法支持4种不同的类型：

      private property(私有属性)，
      dynamic public property(动态公有属性)，
      static public property/prototype property(静态公有属性或原型属性)，
      static property(静态属性或类属性)。

    私有属性对外界完全不具备访问性，可以通过内部的getter和setter（都是模拟）；动态公有属性外界可以访问，每个对象实例持有一个副本，不会相互影响；原型属性每个对象实例共享唯一副本；类属性不作为实例的属性，只作为类的属性。

  2.4原型(prototype)

    习语”照葫芦画瓢“，这里的葫芦就是原型，瓢是类型，可以表示成：

      瓢.prototype=某只葫芦 or 瓢.prototype=new 葫芦()

    因为原型属性每个对象实例共享唯一副本，所以当实例中的一个调整了一个原型属性的值时，所有实例调用这个属性时都将发生变化，这点需要注意

  2.5继承

    如果两个类都是同一个实例的类型，那么它们之间存在着某种关系，我们把同一个实例的类型之间的泛化 关系称为继承。C#和JAVA中都有这个，具体的理解就不说了。在javascript中，并不直接从方法上支持继承，但是就像前面说的，可以模拟啊方法可以归纳为四种：

      构造继承法，原型继承法，实例继承法和拷贝继承法。
      
    融会贯通之后，还有混合继 续法，这是什么法，就是前面四种挑几种混着来~ 